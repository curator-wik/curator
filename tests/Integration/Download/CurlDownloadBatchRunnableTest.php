<?php


namespace Curator\Tests\Integration\Download;


use Curator\APIModel\v1\BatchRunnerRawProgressMessage;
use Curator\Download\CurlDownloadBatchRunnable;
use Curator\IntegrationConfig;
use Curator\Task\TaskInterface;
use mbaynton\BatchFramework\TaskInstanceStateInterface;

class CurlDownloadBatchRunnableTest extends \PHPUnit_Framework_TestCase {
  /**
   * @var resource $h_server_proc
   *
   */
  protected static $h_server_proc;

  protected static $random512 = '';

  /**
   * @var int $count
   * Used to vary the url, and thus the download file, to ensure
   * readbacks are really from the current test.
   */
  protected $count = 0;

  /**
   * @var TaskInterface $task
   */
  protected $task;

  /**
   * @var TaskInstanceStateInterface $taskState
   */
  protected $taskState;

  // Start a development webserver on :8080.
  public static function setUpBeforeClass() {
    parent::setUpBeforeClass();

    self::installDownloadData();

    $devnull = fopen('/dev/null', 'r+');
    $foo = [];

    $h_server_proc = proc_open(
      'exec /usr/bin/env php -S localhost:8080 -t /tmp',
      [0 => $devnull, 1 => $devnull, 2 => $devnull],
      $foo
    );
    self::$h_server_proc = $h_server_proc;

    // Wait for the development server to start listening.
    $attempts = 0;
    while ($attempts < 100000) {
      usleep(1000);
      if (@file_get_contents('http://localhost:8080/random512.dat')) {
        break;
      }
      $attempts++;
    }
  }

  // Stop the development webserver.
  public static function tearDownAfterClass() {
    parent::tearDownAfterClass(); // TODO: Change the autogenerated stub

    proc_terminate(self::$h_server_proc, SIGTERM);
    proc_close(self::$h_server_proc);
    self::$h_server_proc = FALSE;
  }

  protected static function installDownloadData() {
    $fh = fopen('/dev/urandom', 'r');
    $random512 = fread($fh, 512 * 1024);
    fclose($fh);
    file_put_contents('/tmp/random512.dat', $random512);
    self::$random512 = $random512;
  }

  public function setUp() {
    parent::setUp();

    if (self::$h_server_proc === FALSE) {
      $this->fail('Test fails because development webserver is not operational.');
    }

    // At present, this single-step runner does not use the Task or TaskInstanceState,
    // so not bothering to really give them.
    $this->task = $this->getMockBuilder('\mbaynton\BatchFramework\TaskInterface')
      ->getMock();
    $this->taskState = $this->getMockBuilder('mbaynton\BatchFramework\TaskInstanceStateInterface')
      ->getMock();
  }

  protected function sutFactory($opts = []) {
    $url = isset($opts['url']) ? $opts['url'] : sprintf("http://localhost:8080/random512.dat?count=%d", $this->count);

    $sut = new CurlDownloadBatchRunnable(
      IntegrationConfig::getNullConfig(),
      1,
      $url
    );
    $this->count++;
    return $sut;
  }

  public function testFileIsDownloadedToDisk() {
    $sut = $this->sutFactory();

    $file = $sut->run($this->task, $this->taskState);

    $this->assertEquals(
      self::$random512,
      file_get_contents($file),
      'Downloaded random data differed from the source copy.'
    );
  }

  /**
   * @expectedException \RuntimeException
   * @expectedExceptionMessage 404 Not Found
   */
  public function testFileDownloadFailureIsCorrectlyReported() {
    $sut = $this->sutFactory(['url' => 'http://localhost:8080/does/not/exist']);
    $file = $sut->run($this->task, $this->taskState);
  }

  /**
   * @expectedException \RuntimeException
   * @expectedExceptionMessage Connection refused
   */
  public function testFileDownloadFailureIsCorrectlyReported_2() {
    $sut = $this->sutFactory(['url' => 'http://localhost:8079/']);
    $file = $sut->run($this->task, $this->taskState);
  }

  // TODO: testFileDownloadProgressIsReported
  public function testDownloadProgressIsReported() {
    $sut = $this->sutFactory();
    $called_counter = 0;
    $last_pct_reported = 0;
    $sut->setUpdateMessageCallback(function(BatchRunnerRawProgressMessage $m) use (&$called_counter, &$last_pct_reported) {
      $called_counter++;
      $this->assertGreaterThanOrEqual($last_pct_reported, $m->pct);
      $this->assertGreaterThanOrEqual(0, $m->pct);
      $this->assertLessThanOrEqual(100, $m->pct);
      $last_pct_reported = $m->pct;
    });

    $file = $sut->run($this->task, $this->taskState);

    // At least 2 calls expected: 1 after transfer completes, 1+ by cURL.
    $this->assertGreaterThan(1, $called_counter);
  }
}
