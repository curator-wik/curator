<?php


namespace Curator\Tests\Integration\Download;


use Curator\Download\CurlDownloadBatchRunnable;
use Curator\IntegrationConfig;
use Curator\Task\TaskInterface;
use mbaynton\BatchFramework\TaskInstanceStateInterface;

class CurlDownloadBatchRunnableTest extends \PHPUnit_Framework_TestCase {
  /**
   * @var resource $h_server_proc
   *
   */
  protected static $h_server_proc;

  protected static $random512 = '';

  /**
   * @var int $count
   * Used to vary the url, and thus the download file, to ensure
   * readbacks are really from the current test.
   */
  protected $count = 0;

  /**
   * @var TaskInterface $task
   */
  protected $task;

  /**
   * @var TaskInstanceStateInterface $taskState
   */
  protected $taskState;

  // Start a development webserver on :8080.
  public static function setUpBeforeClass() {
    parent::setUpBeforeClass();

    self::installDownloadData();

    $devnull = fopen('/dev/null', 'r+');
    $foo = [];

    $h_server_proc = proc_open(
      'exec /usr/bin/env php -S localhost:8080 -t /tmp',
      [0 => $devnull, 1 => $devnull, 2 => STDERR],
      $foo
    );
    self::$h_server_proc = $h_server_proc;

    // Wait for the development server to start listening.
    $attempts = 0;
    while ($attempts < 100000) {
      usleep(1000);
      if (@file_get_contents('http://localhost:8080/random512.dat')) {
        break;
      }
      $attempts++;
    }
  }

  // Stop the development webserver.
  public static function tearDownAfterClass() {
    parent::tearDownAfterClass(); // TODO: Change the autogenerated stub

    proc_terminate(self::$h_server_proc, SIGTERM);
    proc_close(self::$h_server_proc);
    self::$h_server_proc = FALSE;
  }

  protected static function installDownloadData() {
    $fh = fopen('/dev/urandom', 'r');
    $random512 = fread($fh, 512 * 1024);
    fclose($fh);
    file_put_contents('/tmp/random512.dat', $random512);
    self::$random512 = $random512;
  }

  public function setUp() {
    parent::setUp();

    if (self::$h_server_proc === FALSE) {
      $this->fail('Test fails because development webserver is not operational.');
    }

    // At present, this single-step runner does not use the Task or TaskInstanceState,
    // so not bothering to really give them.
    $this->task = $this->getMockBuilder('\mbaynton\BatchFramework\TaskInterface')
      ->getMock();
    $this->taskState = $this->getMockBuilder('mbaynton\BatchFramework\TaskInstanceStateInterface')
      ->getMock();
  }

  protected function sutFactory() {
    $sut = new CurlDownloadBatchRunnable(
      IntegrationConfig::getNullConfig(),
      1,
      sprintf("http://localhost:8080/random512.dat?count=%d", $this->count)
    );
    $this->count++;
    return $sut;
  }

  public function testFileIsDownloadedToDisk() {
    $sut = $this->sutFactory();

    $file = $sut->run($this->task, $this->taskState);

    $this->assertEquals(
      self::$random512,
      file_get_contents($file),
      'Downloaded random data differed from the source copy.'
    );
  }

  // TODO: testFileDownloadFailureIsCorrectlyReported

  // TODO: testFileDownloadProgressIsReported
}
